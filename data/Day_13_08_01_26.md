# Day 13, 08.01.2026
Protocol writer: Preeti

---
## __Introduction__
On wednesdays, we start with the Career Compass Module (self study) and then do discussion of the previous day protocol. The main lecture starts after Lunch. It was about Functions. It included an Introduction to Functions, How to define Functions and then finally Calling the Function which brings about the output of the code.

## __Schedule__ 
|Time|Notes|

|09:00 - 11:30|Career Compass Module Time|
|11:30 - 12:00|Protocol discussion on previous day topic- For and While loops|
|12:00 - 13:00|Lunch break|
|13:00 - 14:00|Main Topic Discussion on Functions| 
|14:00 - 14:45|Working on the exercises on Function| 
|14:45 - 16:30|Discussing the exercises in class Essential_Function_Exercise| 
|16:30 - 18:00|Discussing Github and VSCode Workflow and troubleshooting|


---

## __Functions__ 

### __Introduction__

* Functions are known as 'subroutines' in computer science. 
* A subroutine is defined as a sequence of instructions that performs a specific task, packaged together as a unit - i.e. a small independent piece of code. 
*. Functions are characterized by:  
(i) Reusability- In order to be concise and minimise repitition of similar instructions, we wrap up the instructions under a tool as function.(Based on DRY[Dont Repeat Yourself] methodology).
(ii) Abstraction- The implementation within a function is hidden from the caller (abstracted away), yet mostly the in-built Functions work without error(until it needs some change).


###__Understanding the Functions__

* A function is a named block of code that you can reuse whenever you want.

You define it once
You call it whenever you need it
It can take inputs (called parameters)
It can give back outputs (called return values)

* In this eg:

```
def greet(name):  #means define a function called greet that takes one input called name. 
    print("Hello, " + name + "!")

greet("Preeti!"). # The code runs on calling the function greet(name)
greet("Everyone!")

output is:-
Hello, Preeti!
Hello, Everyone!
```


### Requirements for defining a function__
1. Use the word- def
2. Use () after the name of the function to add any parameters to the function
3. Use colon ':' after the bracket it signifies python that the function definition is over and the block starts from thereon.
4. This is followed by the block of code with all lines indented by one level.
5. Call the function: function_name() means execute the code inside the function. If we do without the parentheses,  Python looks at it as a variable called function_name  not a function.

### Use of Return function and its indentation
* It ends the function immediately
* It sends a value back to where the function was called
 * Comparing these 2 examples

eg. 1
def get_evens(): 
    evens = []
    for element in range(10): 
        if element % 2 == 0: 
            evens.append(element)
    return evens

print('now the output is: ', get_evens())
 
 What happens here:
 1. evens starts as an empty list → []
 2. The for loop runs through all numbers 0–9
 3. Every even number is added to evens 0, 2, 4, 6, 8
 4. After the loop finishes, return evens runs and The full list is returned
 5. Return is indented in for loop so it breaks once the entire code runs

 eg: 2
 def get_evens(): 
    evens = []
    for element in range(10): 
        if element % 2 == 0: 
            evens.append(element)
            return evens

print('now the output is: ', get_evens())
 What happens here
 evens starts as []

1. Loop starts
2. First even number is 0, then 0 is appended → evens = [0]
3. return evens runs immediately
4. Function stops execution completely
5. Loop never continues


### Passing arguments to a function
* The variable name which the user adds within parenthesis are variable parameters. Values that are passed to a function within parenthesis are arguments.


eg.
 def get_multiples(n=5, divisor=2): 
    multiples_lst = []
    for element in range(n): 
        if element % divisor == 0: 
            multiples_lst.append(element)
    return multiples_lst
print(get_multiples())            #output [0,2,4]
print(get_multiples(20, 3))       #output [0, 3, 6, 9, 12, 15, 18]
print(get_multiples(divisor=4)).  #output [0, 4]

* Getting different output by changing the arguments







   

