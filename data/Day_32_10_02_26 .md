
**Protocol writer:**<br> 
Andrea

---

## Introduction
As usual, the day began with a discussion of the minutes, followed by the group exercises from the previous day. Groupby and create were the topics of the day, as well as installing the schema.

---

## Schedule
| Time | Notes |
|------|-------|
| 09:00 ‚Äì 09:30 | Daily protocol |
| 09:30 ‚Äì 10:40 | Exercises from previous lesson |
| 10:40 ‚Äì 11:00 | Break |
| 11:00 ‚Äì 11:50 | Groupby |
| 11:50 ‚Äì 13:00 | Break |
| 13:00 ‚Äì 13:30 | Exercises |
| 13:30 ‚Äì 15:40 | Schema and "Create" |
| 15:40 ‚Äì 00:00 | Exercises continuation |


---


## üü© Morning (11:00‚Äì11:45) ‚Äî Aggregations + GROUP BY 

> **Focus:** Aggregate functions, rounding behavior, derived metrics, grouping & filtering groups.

---

### üü® 1) Aggregations on `airports`

```sql
-- MAX altitude
SELECT MAX(alt) AS max_alt
FROM airports;

-- MIN altitude
SELECT MIN(alt) AS min_alt
FROM airports;

-- Total number of rows
SELECT COUNT(*) AS total_rows
FROM airports;

-- Average altitude
SELECT AVG(alt) AS avg_alt
FROM airports;

2) Aggregations on flights (filters by date / route)

-- Total distance on a specific date
SELECT SUM(distance) AS total_distance
FROM flights
WHERE flight_date = '2025-02-18';

-- Average air_time for route BOS -> HNL + rounded version
SELECT
    AVG(air_time)           AS avg_air_time,
    ROUND(AVG(air_time), 2) AS rounded_avg_air_time
FROM flights
WHERE origin = 'BOS'
  AND dest   = 'HNL';

‚úÖ Formula (highlight): rounded_avg_air_time = ROUND(AVG(air_time), 2)

üü® 3) Rounding vs. FLOOR/CEIL (PostgreSQL)

-- ROUND examples (numeric casting)
SELECT ROUND(2.25::numeric, 1) AS round_example_1;
SELECT ROUND(2.45, 1)          AS round_example_2;

-- FLOOR and CEIL/CEILING applied to AVG(air_time)
SELECT
    AVG(air_time) + 0.5  AS avg_plus,
    FLOOR(AVG(air_time)) AS floor_avg
FROM flights
WHERE origin = 'BOS'
  AND dest   = 'HNL';

SELECT
    AVG(air_time) + 0.5 AS avg_plus,
    CEIL(AVG(air_time)) AS ceil_avg
FROM flights
WHERE origin = 'BOS'
  AND dest   = 'HNL';

SELECT
    AVG(air_time) + 0.5    AS avg_plus,
    CEILING(AVG(air_time)) AS ceiling_avg
FROM flights
WHERE origin = 'BOS'
  AND dest   = 'HNL';

‚úÖ Key note: CEIL() and CEILING() are synonyms

üü® 4) Derived KPI (speed proxy): miles per minute

SELECT
    AVG(air_time)                 AS avg_time,
    AVG(distance)                 AS avg_distance,
    AVG(distance) / AVG(air_time) AS miles_per_min
FROM flights
WHERE origin = 'BOS'
  AND dest   = 'HNL';

‚úÖ Formula (highlight): miles_per_min = AVG(distance) / AVG(air_time)

üü® 5) COUNT(DISTINCT), casting to avoid integer division, ROUND, modulo %

-- WARNING: may result in integer division depending on types
SELECT
    COUNT(faa)              AS total_airports,
    COUNT(DISTINCT country) AS total_countries,
    COUNT(faa) / COUNT(DISTINCT country) AS airports_per_country_integer_div
FROM airports;

-- Correct: force decimal division using * 1.0
SELECT
    COUNT(faa)              AS total_airports,
    COUNT(DISTINCT country) AS total_countries,
    COUNT(faa) * 1.0 / COUNT(DISTINCT country) AS airports_per_country_decimal
FROM airports;

-- Rounded ratio + modulo remainder example
SELECT
    COUNT(faa) AS total_airports,
    COUNT(DISTINCT country) AS total_countries,
    ROUND(COUNT(faa) * 1.0 / COUNT(DISTINCT country), 2) AS airports_per_country_rounded,
    COUNT(faa) % COUNT(DISTINCT country) AS remainder_example
FROM airports;

‚úÖ Formulas (highlight):

airports_per_country = COUNT(faa) * 1.0 / COUNT(DISTINCT country)

remainder = COUNT(faa) % COUNT(DISTINCT country)

üü® 6) Convert total minutes into days / hours / minutes

SELECT
    SUM(air_time) / 60 / 24 AS days,
    SUM(air_time) / 60 % 24 AS hours,
    SUM(air_time) % 60      AS mins
FROM flights
WHERE flight_date = '2025-01-01';

‚úÖ Formulas (highlight):

days = SUM(air_time) / 60 / 24

hours = (SUM(air_time) / 60) % 24

mins = SUM(air_time) % 60

üü¶ GROUP BY Block (Morning Add-on): life_expectancy

üü® 7) Explore table

SELECT *
FROM life_expectancy
ORDER BY country;

üü® 8) COUNT years per country

SELECT
    country,
    COUNT(year) AS total_years
FROM life_expectancy
GROUP BY country;

üü® 9) COUNT + AVG per country (exercise completed)

SELECT
    country,
    COUNT(*)             AS total_years,
    AVG(life_expectancy) AS avg_life_expectancy
FROM life_expectancy
GROUP BY country;

‚úÖ Formula (highlight): avg_life_expectancy = AVG(life_expectancy)

üü® 10) AVG per country, rounded, ordered descending

SELECT
    country,
    AVG(life_expectancy) AS avg_raw,
    ROUND(AVG(life_expectancy)::numeric, 2) AS avg_rounded
FROM life_expectancy
GROUP BY country
ORDER BY avg_rounded DESC;

‚úÖ Formula (highlight): avg_rounded = ROUND(AVG(life_expectancy)::numeric, 2)

üü® 11) WHERE vs HAVING (filtering aggregated values)
‚úÖ WHERE filters rows before grouping:

SELECT
    country,
    ROUND(AVG(life_expectancy)) AS avg_life_expectancy
FROM life_expectancy
WHERE country IN ('United States','Chile','Italy','Germany','China')
GROUP BY country
ORDER BY avg_life_expectancy DESC;

‚úÖ HAVING filters groups after aggregation:

SELECT
    country,
    ROUND(AVG(life_expectancy)) AS avg_life_expectancy
FROM life_expectancy
GROUP BY country
HAVING AVG(life_expectancy) >= 50
ORDER BY avg_life_expectancy DESC;

‚úÖ Rule (highlight): Use HAVING when the filter depends on an aggregate like AVG(), COUNT(), etc.

üü® 12) GROUP BY multiple columns (flights per day + airline)

SELECT
    flight_date,
    airline,
    COUNT(flight_number) AS total_flights,
    AVG(arr_delay)       AS delay_avg,
    SUM(cancelled)       AS cancelled_total,
    SUM(diverted)        AS diverted_total
FROM flights
GROUP BY flight_date, airline;

‚úÖ Formulas (highlight):

total_flights = COUNT(flight_number)

delay_avg = AVG(arr_delay)

cancelled_total = SUM(cancelled)

diverted_total = SUM(diverted)


üü• Afternoon (13:30‚Äì15:40) ‚Äî Creating, Modifying, Deleting Tables

Focus: schemas, CTAS (create table as select), drop/recreate patterns, insert, alter, update, delete, truncate.

üü® 1) Schema handling in DBeaver (concept)

Default schema: public

Switch ‚ÄúActive catalog/schema‚Äù to your personal schema in DBeaver

Reference any table by prefixing schema name:
‚úÖ public.life_expectancy

üü® 2) Aggregated country query (base for table creation)

SELECT
    country,
    AVG(life_expectancy) AS avg_life_expectancy,
    MIN(year)            AS first_year,
    MAX(year)            AS last_year
FROM public.life_expectancy
GROUP BY country
ORDER BY country;

üü® 3) Create table from query (CTAS) + verify

DROP TABLE IF EXISTS countries;

CREATE TABLE countries AS
SELECT
    country,
    AVG(life_expectancy) AS avg_life_expectancy,
    MIN(year)            AS first_year,
    MAX(year)            AS last_year
FROM public.life_expectancy
GROUP BY country
ORDER BY country;

SELECT * FROM countries;

‚úÖ Formula (highlight): CTAS = CREATE TABLE <name> AS SELECT ...

üü® 4) Insert a row + verify

INSERT INTO countries
VALUES ('Transylvania', 200.99999, 1200, 2016);

SELECT *
FROM countries
WHERE country = 'Transylvania';

üü® 5) Alter table: add column + update values

ALTER TABLE countries
ADD COLUMN period_length numeric;

UPDATE countries
SET period_length = last_year - first_year;

SELECT * FROM countries;

‚úÖ Formula (highlight): period_length = last_year - first_year

üü® 6) Update a specific row (data correction)

UPDATE countries
SET first_year    = 1500,
    period_length = last_year - 1500
WHERE country = 'Transylvania';

üü® 7) Delete row + drop column (and recreate)

DELETE FROM countries
WHERE country = 'Transylvania';

ALTER TABLE countries
DROP COLUMN period_length;

-- recreate column (no undo in PostgreSQL)
ALTER TABLE countries
ADD COLUMN period_length numeric;

UPDATE countries
SET period_length = last_year - first_year;

üü® 8) Create empty table with constraints + fill via INSERT‚Ä¶SELECT

We can pass so-called constraints: 
  - "unique" to only allow unique states
  - "NOT NULL" to not allow null values in this column
 - "PRIMARY KEY" to set this column as the table's primary key
 - we can also combine these constraints, e.g. unique NOT NULL


DROP TABLE IF EXISTS countries_selection;

CREATE TABLE countries_selection (
    state            VARCHAR(255) UNIQUE,
    le_avg           NUMERIC NOT NULL,
    record_start     INTEGER,
    record_end       INTEGER,
    record_duration  INTEGER
);

SELECT * FROM countries_selection;

INSERT INTO countries_selection (state, le_avg, record_start, record_end, record_duration)
SELECT
    country,
    ROUND(avg_life_expectancy::numeric, 2),
    first_year,
    last_year,
    period_length
FROM countries
WHERE country IN ('Andorra', 'Brazil', 'Germany', 'Nepal', 'Iceland');

SELECT * FROM countries_selection;

‚úÖ Formulas (highlight):

le_avg = ROUND(avg_life_expectancy::numeric, 2)

record_duration = period_length

üü® 9) TRUNCATE vs DROP (practical)

TRUNCATE countries_selection;

DROP TABLE IF EXISTS countries_selection;

‚úÖ Rule (highlight):

TRUNCATE = remove all rows, keep table structure

DROP = remove table structure + data

‚úÖ Notes / Common fixes (from the original notes)

delet ‚Üí DELETE

colum ‚Üí COLUMN

last-year ‚Üí last_year

le-avg ‚Üí le_avg